<?xml version="1.0" encoding="UTF-8"?>

<!-- This is a liberal adaptation of tabbrowser.xml, so I'm including their
     license and contributor list here. -->

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is this file as it was released on March 28, 2001.
   -
   - The Initial Developer of the Original Code is
   - David Hyatt.
   - Portions created by the Initial Developer are Copyright (C) 2001
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   David Hyatt <hyatt@netscape.com> (Original Author of <tabbrowser>)
   -   Mike Connor <mconnor@steelgryphon.com>
   -   Peter Parente <parente@cs.unc.edu>
   -   Giorgio Maone <g.maone@informaction.com>
   -   Asaf Romano <mozilla.mano@sent.com>
   -   Seth Spitzer <sspitzer@mozilla.org>
   -   Simon BÃ¼nzli <zeniko@gmail.com>
   -   Michael Ventnor <ventnor.bugzilla@yahoo.com.au>
   -   Mark Pilgrim <pilgrim@gmail.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings [
<!ENTITY % tabBrowserDTD SYSTEM "chrome://celtx/locale/tabbrowser.dtd" >
%tabBrowserDTD;
<!ENTITY % globalDTD SYSTEM "chrome://global/locale/global.dtd" >
%globalDTD;
]>

<bindings id="tabEditorBindings"
  xmlns="http://www.mozilla.org/xbl"
  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
  xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="tabeditor">
    <resources>
      <stylesheet src="chrome://celtx/skin/tabeditor.css"/>
    </resources>

    <content>
      <xul:tabbox anonid="tabbox"
                  flex="1"
                  eventnode="document"
                  xbl:inherits="handleCtrlPageUpDown"
                  onselect="if (event.target.localName != 'tabpanels' &amp;&amp;
                                event.target.localName != 'tabs') return;
                            this.parentNode.tabSelected();
                            event.preventDefault();">
        <xul:hbox class="tab-drop-indicator-bar"
                  collapsed="true"
                  chromedir="&locale.dir;">
          <xul:hbox class="tab-drop-indicator"
                    mousethrough="always"/>
        </xul:hbox>
        <xul:hbox class="tabeditor-strip"
                  collapsed="true"
                  anonid="strip"
                  ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode.parentNode); event.stopPropagation();"
                  ondragover="nsDragAndDrop.dragOver(event, this.parentNode.parentNode); event.stopPropagation();"
                  ondragdrop="nsDragAndDrop.drop(event, this.parentNode.parentNode); event.stopPropagation();"
                  ondragexit="nsDragAndDrop.dragExit(event, this.parentNode.parentNode); event.stopPropagation();">
          <!-- Insert tooltip and contextual menu stuff here -->
          <xul:tabs class="tabeditor-tabs"
                    flex="1"
                    anonid="tabcontainer"
                    setfocus="false"
                    onclick="this.parentNode.parentNode.parentNode.onTabClick(event);"
                    onclosetab="var node = this.parentNode;
                                while (node.localName != 'tabeditor')
                                  node = node.parentNode;
                                node.removeCurrentTab();"/>
        </xul:hbox>
        <xul:tabpanels flex="1"
                       class="plain"
                       anonid="panelcontainer"
                       onload="this.parentNode.onPanelLoad(event);
                               event.stopPropagation();"/>
      </xul:tabbox>
      <children/>
    </content>
    <implementation implements="nsIDOMEventListener">
      <field name="mTabBox" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "tabbox");
      </field>
      <field name="mTabDropIndicatorBar">
        this.mTabBox.childNodes[0]
      </field>
      <field name="mStrip" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "strip");
      </field>
      <field name="mTabContainer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "tabcontainer");
      </field>
      <field name="mPanelContainer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid",
          "panelcontainer");
      </field>
      <field name="mTabs" readonly="true">
        this.mTabContainer.childNodes
      </field>
      <field name="mCurrentTab">null</field>
      <field name="mCurrentEditor">null</field>
      <field name="mTabListeners">new Array()</field>

      <method name="getEditorAtIndex">
        <parameter name="aIndex"/>
        <body>
        <![CDATA[
          // return this.mTabContainer.childNodes[aIndex].linkedEditor;
          return this.mTabContainer.childNodes[aIndex]
            .linkedFrame.contentWindow;
        ]]>
        </body>
      </method>

      <method name="getEditorIndexForDocument">
        <parameter name="aDocument"/>
        <body>
        <![CDATA[
          for (var i = 0; i < this.mTabContainer.childNodes.length; ++i) {
            if (this.mTabContainer.childNodes[i].value == aDocument)
              return i;
          }
          return -1;
        ]]>
        </body>
      </method>

      <method name="getEditorForDocument">
        <parameter name="aDocument"/>
        <body>
        <![CDATA[
          var index = this.getEditorIndexForDocument(aDocument);
          if (index < 0)
            return null;
          return this.getEditorAtIndex(index);
        ]]>
        </body>
      </method>

      <method name="addTabListener">
        <parameter name="aListener"/>
        <body>
        <![CDATA[
          for (var i = 0; i < this.mTabListeners.length; i++) {
            if (this.mTabListeners[i] == aListener)
              return;
          }
          this.mTabListeners.push(aListener);
        ]]>
        </body>
      </method>

      <method name="removeTabListener">
        <parameter name="aListener"/>
        <body>
        <![CDATA[
          for (var i = 0; i < this.mTabListeners.length; i++) {
            if (this.mTabListeners[i] == aListener) {
              this.mTabListeners.splice(i, 1);
              return;
            }
          }
        ]]>
        </body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body>
        <![CDATA[
          if (aEvent.type != "load")
            return;
          if (! (aEvent.target instanceof XULDocument))
            return;

          for (var i = 0; i < this.mTabs.length; ++i) {
            if (this.mTabs[i].linkedFrame &&
                this.mTabs[i].linkedFrame.contentDocument == aEvent.target) {
              var tabevent = {
                cancelable: false,
                cancelled: false,
                target: this.mTabs[i],
                type: "TabLoad",
                preventDefault: function () {}
              };
              this.dispatchTabEvent(tabevent);
              this.mTabs[i].linkedFrame.contentWindow.removeEventListener(
                "load", this, false);
              break;
            }
          }
        ]]>
        </body>
      </method>

      <!-- Dispatch our custom (non-traversing) event -->
      <method name="dispatchTabEvent">
        <parameter name="aEvent"/>
        <body>
        <![CDATA[
          var handlerName = "on" + aEvent.type;
          for (var i = 0; i < this.mTabListeners.length; ++i) {
            if (aEvent.cancelled)
              return;
            if (handlerName in this.mTabListeners[i]) {
              try {
                this.mTabListeners[i][handlerName](aEvent);
              }
              catch (ex) {
                dump("*** " + handlerName + ": " + ex + "\n");
              }
            }
          }
        ]]>
        </body>
      </method>

      <method name="tabSelected">
        <body>
        <![CDATA[
          var newEditor = this.getEditorAtIndex(
            this.mTabContainer.selectedIndex);
          if (this.mCurrentEditor == newEditor) {
            if (this.mTabBox.selectedPanel != this.selectedTab.linkedFrame)
              this.mTabBox.selectedPanel = this.selectedTab.linkedFrame;
            return;
          }

          if (false && this.mCurrentEditor) {
            // Save the focused element if it is in the editor window
            var focusedWindow = document.commandDispatcher.focusedWindow;
            var saveFocus = false;

            // Not sure what this means...
            var contentWindow = this.mCurrentEditor;

            while (contentWindow) {
              if (contentWindow == focusedWindow) {
                saveFocus = true;
                break;
              }
              if (contentWindow.parent == contentWindow) {
                break;
              }
              contentWindow = contentWindow.parent;
            }

            if (saveFocus) {
              this.mCurrentEditor.focusedWindow = focusedWindow;
              this.mCurrentEditor.focusedElement =
                document.commandDispatcher.focusedElement;
            }
            if (this.mCurrentEditor.focusedElement instanceof NSHTMLElement ||
                this.mCurrentEditor.focusedElement instanceof XULElement) {
              this.mCurrentEditor.focusedElement.blur();
            }
            else {
              this.mCurrentEditor.focusedElement = null;
            }

            this.mCurrentEditor.blur();
          }

          this.mCurrentEditor = newEditor;
          this.mCurrentTab = this.selectedTab;
          this.mTabBox.selectedPanel = this.mCurrentTab.linkedFrame;

          this.mCurrentEditor.focus();

          if (document.commandDispatcher.focusedElement &&
              document.commandDispatcher.focusedElement.parentNode ==
              this.mCurrentTab.parentNode) {
            // The focus is on a tab in the same tab panel
            return;
          }

          var whatToFocus = this.mCurrentEditor;
          if (this.mCurrentEditor.focusedElement) {
            if (this.mCurrentEditor.focusedElement.parentNode !=
                this.mCurrentTab.parentNode) {
              whatToFocus = this.mCurrentEditor.focusedElement;
            }
          }
          else if (this.mCurrentEditor.focusedWindow) {
            whatToFocus = this.mCurrentEditor.focusedWindow;
          }

          // Change focus for this window to |whatToFocus|, without
          // focusing the window itself.
          var cmdDispatcher = document.commandDispatcher;

          var ww =
            Components.classes["@mozilla.org/embedcomp/window-watcher;1"]
                      .getService(Components.interfaces.nsIWindowWatcher);
          if (ww.activeWindow == window) {
            cmdDispatcher.suppressFocusScroll = true;
            if (whatToFocus instanceof HTMLElement ||
                whatToFocus instanceof XULElement ||
                whatToFocus instanceof Window) {
              whatToFocus.focus();
            }
            else if (whatToFocus instanceof Node) {
              var content = window.content;
              if (content instanceof Components.interfaces.nsIInterfaceRequestor)
                content.getInterface(Components.interfaces.nsIDOMWindowUtils).focus(whatToFocus);
            }
            cmdDispatcher.suppressFocusScroll = false;
          }
          else {
            // set the element in command dispatcher so focus will restore
            // properly when the window does become active
            if (whatToFocus instanceof Window) {
              cmdDispatcher.focusedWindow = whatToFocus;
              cmdDispatcher.focusedElement = null;
            }
            else {
              cmdDispatcher.focusedWindow = whatToFocus.ownerDocument.defaultView;
              cmdDispatcher.focusedElement = whatToFocus;
            }
          }

          var event = document.createEvent("Events");
          event.initEvent("TabSelect", true, false);
          this.mCurrentTab.dispatchEvent(event);

          var tabevent = {
            cancelable: false,
            cancelled: false,
            target: this.mCurrentTab,
            type: "TabSelect",
            preventDefault: function () {}
          };
          this.dispatchTabEvent(tabevent);
        ]]>
        </body>
      </method>

      <!-- Middle click to close the tab -->
      <method name="onTabClick">
        <parameter name="event"/>
        <body>
        <![CDATA[
          if (event.button != 1 || event.target.localName != 'tab')
            return;

          this.removeTab(event);
          event.stopPropagation();
        ]]>
        </body>
      </method>

      <method name="setStripVisibilityTo">
        <parameter name="aShow"/>
        <body>
        <![CDATA[
          this.mStrip.collapsed = !aShow;
        ]]>
        </body>
      </method>

      <method name="getStripVisibility">
        <body>
          return !this.mStrip.collapsed;
        </body>
      </method>

      <!--
        Try to keep editor-specific stuff out of here. Ultimately, we're
        just looking to create a window within a window, and leaving the
        details up to the application code.
      -->
      <method name="addTab">
        <parameter name="aTitle"/>
        <parameter name="aImage"/>
        <parameter name="aDocument"/>
        <parameter name="aEditor"/>
        <body>
        <![CDATA[
          var t = document.createElementNS(
            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
            "tab");
          t.setAttribute("label", aTitle);
          t.setAttribute("image", aImage);
          t.setAttribute("crop", "end");
          t.maxWidth = this.mTabContainer.mTabMaxWidth;
          t.minWidth = this.mTabContainer.mTabMinWidth;
          t.width = 0;
          t.setAttribute("flex", "100");
          t.setAttribute("validate", "never");
          t.className = "tabeditor-tab";
          var position = this.mTabContainer.childNodes.length;
          t._tPos = position;
          t.setAttribute("value", aDocument);
          if (this.mTabContainer.childNodes.length == 0) {
            t.setAttribute("selected", "true");
          }
          this.mTabContainer.appendChild(t);
          if (document.defaultView.getComputedStyle(this.mTabContainer, "")
              .direction == "rtl") {
            /* In RTL UI, the tab is visually added to the left side of the
             * tabstrip. This means the tabstip has to be scrolled back in
             * order to make sure the same set of tabs is visible before and
             * after the new tab is added */

            this.mTabContainer.mTabstrip.scrollBoxObject
                .scrollBy(this.mTabContainer.firstChild.boxObject.width, 0);
          }
          var f = document.createElementNS(
            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
            "iframe");
          t.linkedFrame = f;
          t.linkedEditor = f.contentWindow;
          f.setAttribute("flex", "1");
          this.mPanelContainer.appendChild(f);
          if (this.mStrip.collapsed && this.mTabContainer.childNodes.length > 1)
            this.setStripVisibilityTo(true);

          // Okay, close the thing and send a post-close notification
          var _delayedUpdate = function (aTabContainer) {
            aTabContainer.adjustTabstrip();
            aTabContainer.mTabstrip._updateScrollButtonsDisabledState();
          };
          setTimeout(_delayedUpdate, 0, this.mTabContainer);

          // Dispatch a TabOpen event before loading
          var tabevent = {
            cancelable: false,
            cancelled: false,
            target: t,
            type: "TabOpen",
            preventDefault: function () {}
          };
          this.dispatchTabEvent(tabevent);
          this.selectedTab = t;

          // Catch the load event
          f.contentWindow.addEventListener("load", this, false);
          f.setAttribute("src", aEditor);

          return t;
        ]]>
        </body>
      </method>

      <method name="removeCurrentTab">
        <body>
        <![CDATA[
          return this.removeTab(this.mCurrentTab);
        ]]>
        </body>
      </method>

      <method name="removeTab">
        <parameter name="aTab"/>
        <body>
        <![CDATA[
          var tabevent = {
            cancelable: true,
            cancelled: false,
            target: aTab,
            type: "TabWillClose",
            preventDefault: function () {
              if (this.cancelable)
                this.cancelled = true;
            }
          };
          this.dispatchTabEvent(tabevent);

          if (tabevent.cancelled)
            return;

          tabevent.cancelable = false;
          tabevent.type = "TabClosing";
          this.dispatchTabEvent(tabevent);

          // Okay, we've got the go-ahead
          var tabs = this.mTabContainer.childNodes;
          var index = -1;
          if (this.mCurrentTab == aTab) {
            index = this.mTabContainer.selectedIndex;
          }
          else {
            for (var i = 0; i < tabs.length; ++i) {
              if (tabs[i] == aTab) {
                index = i;
                break;
              }
            }
          }
          var currentIndex = this.mTabContainer.selectedIndex;
          var oldTab = aTab;
          oldTab._selected = false;

          this.mTabContainer.removeChild(oldTab);
          this.mPanelContainer.removeChild(oldTab.linkedFrame);

          try {
            // Ensure we stay scrolled to the right if we're at the right side.
            var tabstrip = this.mTabContainer.mTabstrip;
            var scrollPos = {};
            tabstrip.scrollBoxObject.getPosition(scrollPos, {});
            var scrolledSize = {};
            tabstrip.scrollBoxObject.getScrolledSize(scrolledSize, {});
            if (scrollPos.value + tabstrip.boxObject.width
              >= scrolledSize.value) {
              tabstrip.scrollByPixels(-1 * this.mTabContainer.firstChild
                .boxObject.width);
            }
          }
          catch (ex) {}

          // Find the tab to select
          var newIndex = -1;
          if (currentIndex > index)
            newIndex = currentIndex - 1;
          else if (currentIndex < index)
            newIndex = currentIndex;
          else
            newIndex = (index == tabs.length) ? index - 1 : index;

          // Select the new tab
          if (newIndex >= 0) {
            this.selectedTab = tabs[newIndex];
            for (var i = oldTab._tPos; i < tabs.length; ++i) {
              tabs[i]._tPos = i;
            }
            this.mTabBox.selectedPanel = this.mCurrentTab.linkedFrame;
            this.mCurrentTab._selected = true;
          }
          else {
            this.mCurrentTab = null;
            this.mCurrentEditor = null;
          }

          var _delayedUpdate = function (aTabContainer) {
            aTabContainer.adjustTabstrip();
            aTabContainer.mTabstrip._updateScrollButtonsDisabledState();
          };
          setTimeout(_delayedUpdate, 0, this.mTabContainer);

          if (tabs.length == 1)
            this.setStripVisibilityTo(false);

          tabevent.cancelable = false;
          tabevent.type = "TabClose";
          tabevent.target = tabevent.target.getAttribute("value");
          this.dispatchTabEvent(tabevent);
        ]]>
        </body>
      </method>

      <property name="tabContainer" readonly="true">
        <getter>
          return this.mTabContainer;
        </getter>
      </property>

      <property name="selectedTab">
        <getter>
          return this.mTabBox.selectedTab;
        </getter>
        <setter>
          this.mTabBox.selectedTab = val;
          return val;
        </setter>
      </property>

      <property name="selectedEditor">
        <getter>
          return this.selectedTab.linkedEditor;
        </getter>
      </property>

      <!-- Drag and drop observer API -->
      <method name="onDragStart">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragAction"/>
        <body>
        <![CDATA[
          if (aEvent.target.localName == "tab" &&
              aEvent.originalTarget.localName != "toolbarbutton") {
            aXferData.data = new TransferData();

            var docres = aEvent.target.getAttribute("value");
            if (docres)
              aXferData.data.addDataForFlavour("text/x-celtx-rdfres", docres);
          }
        ]]>
        </body>
      </method>

      <method name="canDrop">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
          <![CDATA[
            if (aDragSession.sourceNode &&
                aDragSession.sourceNode.parentNode == this.mTabContainer &&
                (aEvent.screenX >= aDragSession.sourceNode.boxObject.screenX &&
                 aEvent.screenX <= (aDragSession.sourceNode.boxObject.screenX +
                                    aDragSession.sourceNode.boxObject.width)))
                return false;
            if (! aDragSession.sourceNode ||
                aDragSession.sourceNode != this.mTabContainer)
                return false;
            return true;
          ]]>
        </body>
      </method>

      <field name="mDragTime">0</field>
      <field name="mDragOverDelay">350</field>

      <method name="onDragOver">
        <parameter name="aEvent"/>
        <parameter name="aFlavour"/>
        <parameter name="aDragSession"/>
        <body>
          <![CDATA[
            var tabStrip = this.mTabContainer.mTabstrip;
            var ltr = (window.getComputedStyle(this.parentNode, null).direction
                       == "ltr");

            // autoscroll the tab strip if we drag over the scroll
            // buttons, even if we aren't dragging a tab, but then
            // return to avoid drawing the drop indicator
            var pixelsToScroll = 0;
            if (this.mTabContainer.getAttribute("overflow") == "true") {
              var targetAnonid = aEvent.originalTarget.getAttribute("anonid");
              switch (targetAnonid) {
                case "scrollbutton-up":
                  pixelsToScroll = tabStrip.scrollIncrement * -1;
                  break;
                case "scrollbutton-down":
                case "alltabs-button":
                  pixelsToScroll = tabStrip.scrollIncrement;
                  break;
              }
              if (pixelsToScroll)
                tabStrip.scrollByPixels((ltr ? 1 : -1) * pixelsToScroll);
            }

            var isTabDrag = (aDragSession.sourceNode && 
                             aDragSession.sourceNode.parentNode == this.mTabContainer);
            if (!isTabDrag && aEvent.target.localName == "tab") {
              if (!this.mDragTime) 
                this.mDragTime = Date.now();
              if (Date.now() >= this.mDragTime + this.mDragOverDelay)
                this.mTabContainer.selectedItem = aEvent.target;
              return;
            }

            var newIndex = this.getNewIndex(aEvent);
            var ib = this.mTabDropIndicatorBar;
            var ind = ib.firstChild;
            var tabStripBoxObject = tabStrip.scrollBoxObject;
            var minMargin = tabStripBoxObject.x - this.boxObject.x;
            // make sure we don't place the tab drop indicator past the
            // edge, or the containing box will flex and stretch
            // the tab drop indicator bar, which will flex the url bar.  
            // XXX todo
            // just use first value if you can figure out how to get
            // the tab drop indicator to crop instead of flex and stretch
            // the tab drop indicator bar.
            var maxMargin = Math.min(minMargin + tabStripBoxObject.width, 
                                     ib.boxObject.x + ib.boxObject.width -
                                     ind.boxObject.width);
            if (!ltr)
              [minMargin, maxMargin] = [this.boxObject.width - maxMargin,
                                        this.boxObject.width - minMargin];
            var newMargin, tabBoxObject;
            if (pixelsToScroll) {
              // if we are scrolling, put the drop indicator at the edge
              // so that it doesn't jump while scrolling
              newMargin = (pixelsToScroll > 0) ? maxMargin : minMargin;
            }
            else {
              if (newIndex == this.mTabs.length) {
                tabBoxObject =  this.mTabs[newIndex-1].boxObject;
                if (ltr)
                  newMargin = tabBoxObject.screenX - this.boxObject.screenX
                              + tabBoxObject.width;
                else
                  newMargin = this.boxObject.screenX - tabBoxObject.screenX
                              + this.boxObject.width;
              }
              else {
                tabBoxObject =  this.mTabs[newIndex].boxObject;
                if (ltr)
                  newMargin = tabBoxObject.screenX - this.boxObject.screenX;
                else
                  newMargin = this.boxObject.screenX - tabBoxObject.screenX
                              + this.boxObject.width - tabBoxObject.width;
              }
              // ensure we never place the drop indicator beyond our limits
              if (newMargin < minMargin)
                newMargin = minMargin;
              else if (newMargin > maxMargin)
                newMargin = maxMargin;
            }

            ind.style.MozMarginStart = newMargin + 'px';

            ib.collapsed = !aDragSession.canDrop;
          ]]>
        </body>
      </method>

      <method name="onDrop">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragSession"/>
        <body>
          <![CDATA[
            var accelKeyPressed = aEvent.metaKey;
            var draggedTab;
            if (aDragSession.sourceNode &&
                aDragSession.sourceNode.localName == "tab" &&
                aDragSession.sourceNode.parentNode == this.mTabContainer)
              draggedTab = aDragSession.sourceNode;
            if (draggedTab) {
              var newIndex = this.getNewIndex(aEvent);
              // move the dropped tab
              if (newIndex > draggedTab._tPos)
                newIndex--;
              if (newIndex != draggedTab._tPos)
                this.moveTabTo(draggedTab, newIndex);
            }
          ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
          <![CDATA[
            this.mDragTime = 0;

            if (aDragSession.sourceNode &&
                aDragSession.sourceNode.parentNode == this.mTabContainer &&
                aDragSession.canDrop) {
              var target = aEvent.relatedTarget;
              while (target && target != this.mStrip)
                target = target.parentNode;
              if (target)
                return;
            }
            this.mTabDropIndicatorBar.collapsed = true;
          ]]>
        </body>
      </method>

      <method name="getSupportedFlavours">
        <body>
        <![CDATA[
          var flavourSet = new FlavourSet();
          flavourSet.appendFlavour("text/x-celtx-rdfres");
          return flavourSet;
        ]]>
        </body>
      </method>

      <method name="moveTabTo">
        <parameter name="aTab"/>
        <parameter name="aIndex"/>
        <body>
        <![CDATA[
          this.mTabFilters.splice(aIndex, 0, this.mTabFilters.splice(aTab._tPos, 1)[0]);
          this.mTabListeners.splice(aIndex, 0, this.mTabListeners.splice(aTab._tPos, 1)[0]);

          var oldPosition = aTab._tPos;

          aIndex = aIndex < aTab._tPos ? aIndex: aIndex+1;
          this.mCurrentTab._selected = false;
          // use .item() instead of [] because dragging to the end of the strip goes out of
          // bounds: .item() returns null (so it acts like appendChild), but [] throws
          this.mTabContainer.insertBefore(aTab, this.mTabContainer.childNodes.item(aIndex));

          var i;
          for (i = 0; i < this.mTabContainer.childNodes.length; i++) {
            this.mTabContainer.childNodes[i]._tPos = i;
            this.mTabContainer.childNodes[i]._selected = false;
          }
          this.mCurrentTab._selected = true;
          this.mTabContainer.mTabstrip.scrollBoxObject.ensureElementIsVisible(this.mCurrentTab);

          // Dispatch a TabMove event
          var tabevent = {
            cancelable: false,
            cancelled: false,
            target: aTab,
            type: "TabMove",
            preventDefault: function () {}
          };
          this.dispatchTabEvent(tabevent);

          return aTab;
        ]]>
        </body>
      </method>

      <method name="getNewIndex">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            var i;
            if (window.getComputedStyle(this.parentNode, null)
                .direction == "ltr") {
              for (i = aEvent.target.localName == "tab" ?
                  aEvent.target._tPos : 0; i < this.mTabs.length; i++) {
                if (aEvent.screenX < this.mTabs[i].boxObject.screenX
                    + this.mTabs[i].boxObject.width / 2) 
                  return i;
              }
            }
            else {
              for (i = aEvent.target.localName == "tab" ?
                  aEvent.target._tPos : 0; i < this.mTabs.length; i++) {
                if (aEvent.screenX > this.mTabs[i].boxObject.screenX
                    + this.mTabs[i].boxObject.width / 2)
                  return i;
              }
            }

            return this.mTabs.length;
          ]]>
        </body>
      </method>


      <method name="moveTabForward">
        <body>
          <![CDATA[
            var tabPos = this.mCurrentTab._tPos;
            if (tabPos < this.mTabContainer.childNodes.length - 1) {
              this.moveTabTo(this.mCurrentTab, tabPos + 1);
              this.mCurrentTab.focus();
            }
            else if (this.arrowKeysShouldWrap) {
              this.moveTabToStart();
            }
          ]]>
        </body>
      </method>

      <method name="moveTabBackward">
        <body>
          <![CDATA[
            var tabPos = this.mCurrentTab._tPos;
            if (tabPos > 0) {
              this.moveTabTo(this.mCurrentTab, tabPos - 1);
              this.mCurrentTab.focus();
            }
            else if (this.arrowKeysShouldWrap) {
              this.moveTabToEnd();
            }
          ]]>
        </body>
      </method>

      <method name="moveTabToStart">
        <body>
          <![CDATA[
            var tabPos = this.mCurrentTab._tPos;
            if (tabPos > 0) {
              this.moveTabTo(this.mCurrentTab, 0);
              this.mCurrentTab.focus();
            }
          ]]>
        </body>
      </method>

      <method name="moveTabToEnd">
        <body>
          <![CDATA[
            var tabPos = this.mCurrentTab._tPos;
            var length = this.mTabContainer.childNodes.length;
            if (tabPos < length - 1) {
              this.moveTabTo(this.mCurrentTab, length - 1);
              this.mCurrentTab.focus();
            }
          ]]>
        </body>
      </method>

      <method name="moveTabOver">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            var direction = window.getComputedStyle(this.parentNode, null)
              .direction;
            if ((direction == "ltr" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT)
            || (direction == "rtl" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT))
              this.moveTabForward();
            else
              this.moveTabBackward();
          ]]>
        </body>
      </method>

      <field name="_keyEventHandler" readonly="true">
      <![CDATA[({
        tabeditor: this,
        handleEvent: function handleEvent(aEvent) {
          if ('altKey' in aEvent && aEvent.altKey)
            return;
          if ('metaKey' in aEvent && aEvent.metaKey) {
            var offset = 1;
            switch (aEvent.charCode) {
              case '}'.charCodeAt(0):
                offset *= -1;
              case '{'.charCodeAt(0):
                if (window.getComputedStyle(this.tabbrowser, null).direction == "ltr")
                  offset *= -1;

                this.tabeditor.mTabContainer.advanceSelectedTab(offset, true);
                aEvent.stopPropagation();
                aEvent.preventDefault();
                return;
            }
            if ('shiftKey' in aEvent && aEvent.shiftKey)
              return;
            if (aEvent.target.localName == "tabeditor") {
              switch (aEvent.keyCode) {
                case KeyEvent.DOM_VK_UP:
                  this.tabeditor.moveTabBackward();
                  break;
                case KeyEvent.DOM_VK_DOWN:
                  this.tabeditor.moveTabForward();
                  break;
                case KeyEvent.DOM_VK_RIGHT:
                case KeyEvent.DOM_VK_LEFT:
                  this.tabeditor.moveTabOver(aEvent);
                  break;
                case KeyEvent.DOM_VK_HOME:
                  this.tabeditor.moveTabToStart();
                  break;
                case KeyEvent.DOM_VK_END:
                  this.tabeditor.moveTabToEnd();
                  break;
                default:
                  // Stop the keypress event for the above keyboard
                  // shortcuts only.
                  return;
              }
              aEvent.stopPropagation();
              aEvent.preventDefault();
            }
          }
        }
      })]]>
      </field>

      <constructor>
      <![CDATA[
        this.mCurrentEditor = null;
        this.mCurrentTab = null;
        this.mTabLoadListener = {
          handleEvent: function (event) {
            event.target.removeEventListener("load", this, true);
          }
        };
        document.addEventListener("keypress", this._keyEventHandler, false);
      ]]>
      </constructor>

      <destructor>
        document.removeEventListener("keypress", this._keyEventHandler, false);
      </destructor>
    </implementation>
  </binding>

  <binding id="tabeditor-arrowscrollbox" extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
    <content>
      <xul:toolbarbutton class="scrollbutton-up" collapsed="true"
                         xbl:inherits="orient"
                         anonid="scrollbutton-up"
                         onclick="_distanceScroll(event);"
                         onmousedown="_startScroll(-1);"
                         onmouseover="_continueScroll(-1);"
                         onmouseup="_stopScroll();"
                         onmouseout="_pauseScroll();"
                         chromedir="&locale.dir;"/>
      <xul:scrollbox xbl:inherits="orient,align,pack,dir" flex="1" anonid="scrollbox">
        <children/>
      </xul:scrollbox>
      <xul:stack align="center" pack="end" class="scrollbutton-down-stack">
        <xul:hbox flex="1" class="scrollbutton-down-box" 
                           collapsed="true" anonid="down-box"/>
        <xul:hbox flex="1" class="scrollbutton-down-box-animate" 
                           collapsed="true" anonid="down-box-animate"/>
        <xul:toolbarbutton class="scrollbutton-down" collapsed="true"
                           xbl:inherits="orient"
                           anonid="scrollbutton-down"
                           onclick="_distanceScroll(event);"
                           onmousedown="_startScroll(1);"
                           onmouseover="_continueScroll(1);"
                           onmouseup="_stopScroll();"
                           onmouseout="_pauseScroll();"
                           chromedir="&locale.dir;"/>
      </xul:stack>
    </content>
    <implementation>
      <field name="_scrollButtonDownBox">
        document.getAnonymousElementByAttribute(this, "anonid", "down-box");
      </field>
      <field name="_scrollButtonDownBoxAnimate">
        document.getAnonymousElementByAttribute(this, "anonid", "down-box-animate");
      </field>
    </implementation>
    <handlers>
      <handler event="underflow"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.target != this)
          return;

        // Ignore vertical events.
        if (event.detail == 0) {
          return;
        }

        this._scrollButtonDownBox.collapsed = true;
        this._scrollButtonDownBoxAnimate.collapsed = true;
      ]]></handler>

      <handler event="overflow"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.target != this)
          return;

        // Ignore vertical events.
        if (event.detail == 0) {
          return;
        }

        this._scrollButtonDownBox.collapsed = false;
        this._scrollButtonDownBoxAnimate.collapsed = false;
      ]]></handler>

      <handler event="UpdatedScrollButtonsDisabledState"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.target != this)
          return;

        // fix for bug #352353
        // unlike the scrollup button on the tab strip (which is a 
        // simple toolbarbutton) the scrolldown button is 
        // a more complicated stack of boxes and a toolbarbutton
        // so that we can animate when a tab is opened offscreen.
        // in order to style the box with the actual background image
        // we need to manually set the disable state to match the
        // disable state of the toolbarbutton.
        this._scrollButtonDownBox
            .setAttribute("disabled", this._scrollButtonDown.disabled);
      ]]></handler>

    </handlers>
  </binding>

  <binding id="tabeditor-tabs"
           extends="chrome://global/content/bindings/tabbox.xml#tabs">
    <content>
      <xul:stack flex="1" class="tabs-stack">
        <xul:vbox>
          <xul:spacer flex="1"/>
          <xul:hbox class="tabs-bottom" align="center"/>
        </xul:vbox>
        <xul:hbox xbl:inherits="overflow" class="tabs-container">
          <xul:stack>
            <xul:spacer class="tabs-left"/>
          </xul:stack>
          <xul:arrowscrollbox anonid="arrowscrollbox" orient="horizontal" flex="1"
                              style="min-width: 1px;" chromedir="&locale.dir;"
                              class="tabeditor-arrowscrollbox">
            <children/>
          </xul:arrowscrollbox>
          <xul:stack align="center" pack="end" chromedir="&locale.dir;">
            <xul:hbox flex="1" class="tabs-alltabs-box" anonid="alltabs-box"/>
            <xul:hbox flex="1" class="tabs-alltabs-box-animate" anonid="alltabs-box-animate"/>
            <xul:toolbarbutton class="tabs-alltabs-button" type="menu" anonid="alltabs-button"
                               tooltipstring="&listAllTabs.label;">
              <xul:menupopup class="tabs-alltabs-popup" anonid="alltabs-popup"
                             position="after_end"/>
            </xul:toolbarbutton>
          </xul:stack>
          <xul:hbox anonid="tabstrip-closebutton" class="tabs-closebutton-box" align="center" pack="end" chromedir="&locale.dir;">
          <xul:toolbarbutton anonid="tabs-closebutton"
                             class="close-button tabs-closebutton" chromedir="&locale.dir;"/>
          </xul:hbox>
        </xul:hbox>
      </xul:stack>
    </content>
    <implementation implements="nsITimerCallback, nsIDOMEventListener">
      <constructor>
        <![CDATA[
          var pb2 =
              Components.classes['@mozilla.org/preferences-service;1'].
              getService(Components.interfaces.nsIPrefBranch2);

          try {
            this.mTabMinWidth = pb2.getIntPref("celtx.tabs.tabMinWidth");
          } catch (e) {
          }
          try {
            this.mTabMaxWidth = pb2.getIntPref("celtx.tabs.tabMaxWidth");
          } catch (e) {
          }
          try {
            this.mTabClipWidth = pb2.getIntPref("celtx.tabs.tabClipWidth");
          } catch (e) {
          }
          try {
            this.mCloseButtons = pb2.getIntPref("celtx.tabs.closeButtons");
          } catch (e) {
          }

          // this.firstChild.minWidth = this.mTabMinWidth;
          // this.firstChild.maxWidth = this.mTabMaxWidth;
          this.adjustTabstrip();

          pb2.addObserver("celtx.tabs.closeButtons", 
                          this._prefObserver, false);

          window.addEventListener("resize", this, false);

          // Listen to overflow/underflow events on the tabstrip,
          // we cannot put these as xbl handlers on the entire binding because
          // they would also get called for the all-tabs popup scrollbox.
          // Also, we can't rely on event.target becuase these are all
          // anonymous nodes.
          this.mTabstrip.addEventListener("overflow", this, false);
          this.mTabstrip.addEventListener("underflow", this, false);
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          var pb2 =
              Components.classes['@mozilla.org/preferences-service;1'].
              getService(Components.interfaces.nsIPrefBranch2);
          pb2.removeObserver("celtx.tabs.closeButtons", this._prefObserver);

          // Release timer to avoid reference cycles.
          if (this._animateTimer) {
            this._animateTimer.cancel();
            this._animateTimer = null;
          }

          this.mTabstrip.removeEventListener("overflow", this, false);
          this.mTabstrip.removeEventListener("underflow", this, false);
        ]]>
      </destructor>

      <field name="mTabstripWidth">0</field>

      <field name="mTabstrip">
        document.getAnonymousElementByAttribute(this, "anonid", "arrowscrollbox");
      </field>

      <field name="mTabstripClosebutton">
        document.getAnonymousElementByAttribute(this, "anonid", "tabstrip-closebutton");
      </field>

      <field name="_prefObserver">({
        tabbox: this,
  
        observe: function(subject, topic, data)
        {
          if (topic == "nsPref:changed") {
            switch (data) {
            case "celtx.tabs.closeButtons":
              subject.QueryInterface(Components.interfaces.nsIPrefBranch);
              this.tabbox.mCloseButtons = subject.getIntPref("celtx.tabs.closeButtons");
              this.tabbox.adjustTabstrip();
              break;
            }
          }
        },
  
        QueryInterface: function(aIID)
        {
          if (aIID.equals(Components.interfaces.nsIObserver) ||
              aIID.equals(Components.interfaces.nsISupports))
            return this;
          throw Components.results.NS_NOINTERFACE;
        }
        });
      </field>
      <field name="mTabMinWidth">100</field>
      <field name="mTabMaxWidth">250</field>
      <field name="mTabClipWidth">140</field>
      <field name="mCloseButtons">1</field>

      <method name="adjustTabstrip">
        <body><![CDATA[
          // modes for tabstrip
          // 0 - activetab  = close button on active tab only
          // 1 - alltabs    = close buttons on all tabs
          // 2 - noclose    = no close buttons at all
          // 3 - closeatend = close button at the end of the tabstrip
          switch (this.mCloseButtons) {
          case 0:
            this.setAttribute("closebuttons", "activetab");
            break;
          case 1:
            /*
            var width = this.firstChild.boxObject.width;
            // 0 width is an invalid value and indicates
            // an item without display, so ignore.
            if (width > this.mTabClipWidth || width == 0)
            */
              this.setAttribute("closebuttons", "alltabs");
            /*
            else
              this.setAttribute("closebuttons", "activetab");
            */
            break;
          case 2:
          case 3:
            this.setAttribute("closebuttons", "noclose");
            break;
          }
          this.mTabstripClosebutton.collapsed = this.mCloseButtons != 3;
        ]]></body>
      </method>
        
      <field name="_mPrefs">null</field>
      <property name="mPrefs" readonly="true">
        <getter>
        <![CDATA[
          if (!this._mPrefs) {
            this._mPrefs =
              Components.classes['@mozilla.org/preferences-service;1'].
              getService(Components.interfaces.nsIPrefBranch2);
          }
          return this._mPrefs;
        ]]>
        </getter>
      </property>
        
      <method name="_handleTabSelect">
        <body><![CDATA[
          this.mTabstrip.ensureElementIsVisible(this.selectedItem);
        ]]></body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          switch (aEvent.type) {
            case "overflow":
              this.setAttribute("overflow", "true");
              this.mTabstrip.scrollBoxObject
                            .ensureElementIsVisible(this.selectedItem);
              break;
            case "underflow":
              this.removeAttribute("overflow");
              break;
            case "resize":
              var width = this.mTabstrip.boxObject.width;
              if (width != this.mTabstripWidth) {
                this.adjustTabstrip();
                // XXX without this line the tab bar won't budge
                this.mTabstrip.scrollByPixels(1);
                this._handleTabSelect();
                this.mTabstripWidth = width;
              }
              break;
          }
        ]]></body>
      </method>

      <field name="mAllTabsPopup">
        document.getAnonymousElementByAttribute(this, 
                                                "anonid", "alltabs-popup");
      </field>

      <field name="mAllTabsBoxAnimate">
        document.getAnonymousElementByAttribute(this, 
                                                "anonid",
                                                "alltabs-box-animate");
      </field>

      <field name="mDownBoxAnimate">
        this.mTabstrip._scrollButtonDownBoxAnimate;
      </field>

      <field name="mAllTabsButton">
        document.getAnonymousElementByAttribute(this, 
                                                "anonid", "alltabs-button");
      </field>

      <field name="_animateTimer">null</field>
      <field name="_animateStep">-1</field>
      <field name="_animateDelay">25</field>
      <field name="_animatePercents">
       [1.00, 0.85, 0.80, 0.75, 0.71, 0.68, 0.65, 0.62, 0.59, 0.57,
        0.54, 0.52, 0.50, 0.47, 0.45, 0.44, 0.42, 0.40, 0.38, 0.37,
        0.35, 0.34, 0.32, 0.31, 0.30, 0.29, 0.28, 0.27, 0.26, 0.25,
        0.24, 0.23, 0.23, 0.22, 0.22, 0.21, 0.21, 0.21, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.19, 0.19, 0.19, 0.18,
        0.18, 0.17, 0.17, 0.16, 0.15, 0.14, 0.13, 0.11, 0.09, 0.06]
      </field>

      <method name="_stopAnimation">
        <body><![CDATA[
          if (this._animateStep != -1) {
            if (this._animateTimer)
              this._animateTimer.cancel();

            this._animateStep = -1;
            this.mAllTabsBoxAnimate.style.opacity = 0.0;
            this.mDownBoxAnimate.style.opacity = 0.0;
          }
        ]]></body>
      </method>
      
      <method name="_notifyBackgroundTab">
        <parameter name="aTab"/>
        <body><![CDATA[
          var tsbo = this.mTabstrip.scrollBoxObject;
          var tsboStart = tsbo.screenX;
          var tsboEnd = tsboStart + tsbo.width;

          var ctbo = aTab.boxObject;
          var ctboStart = ctbo.screenX;
          var ctboEnd = ctboStart + ctbo.width;

          // Is the new tab already completely visible?
          if (tsboStart <= ctboStart && ctboEnd <= tsboEnd)
            return;

          if (this.mTabstrip.smoothScroll) {
            var selStart = this.selectedItem.boxObject.screenX;
            var selEnd = selStart + this.selectedItem.boxObject.width;

            // Can we make both the new tab and the selected tab completely visible?
            if (Math.max(ctboEnd - selStart, selEnd - ctboStart) <= tsbo.width) {
              this.mTabstrip.ensureElementIsVisible(aTab);
              return;
            }

            this.mTabstrip._smoothScrollByPixels(this.mTabstrip._isLTRScrollbox ?
                                                 selStart - tsboStart : selEnd - tsboEnd);
          }

          // start the flash timer
          this._animateStep = 0;

          if (!this._animateTimer) 
            this._animateTimer =
              Components.classes["@mozilla.org/timer;1"]
                        .createInstance(Components.interfaces.nsITimer);
          else
             this._animateTimer.cancel();

          this._animateTimer.initWithCallback(this, this._animateDelay,
                                              this._animateTimer.TYPE_REPEATING_SLACK);
        ]]></body>
      </method>
      
      <method name="notify">
        <parameter name="aTimer"/>
        <body><![CDATA[
          if (!document)
            aTimer.cancel();

          var percent = this._animatePercents[this._animateStep];
          this.mAllTabsBoxAnimate.style.opacity = percent;
          this.mDownBoxAnimate.style.opacity = percent;

          if (this._animateStep < (this._animatePercents.length - 1))
            this._animateStep++;
          else
            this._stopAnimation();
        ]]></body>
      </method>
    </implementation>
    <handlers>
      <handler event="TabSelect" action="this._handleTabSelect();"/>
      <handler event="mouseover"><![CDATA[
        if (event.originalTarget == this.mAllTabsButton) {
          this.mAllTabsButton
              .setAttribute("tooltiptext",
                            this.mAllTabsButton.getAttribute("tooltipstring"));
        }
        else
          this.mAllTabsButton.removeAttribute("tooltiptext");
      ]]></handler>
    </handlers>
  </binding>

  <!-- alltabs-popup binding
       This binding relies on the structure of the tabbrowser binding.
       Therefore it should only be used as a child of the tabs element.
       This binding is exposed as a pseudo-public-API so themes can customize
       the tabbar appearance without having to be scriptable
       (see globalBindings.xml in Pinstripe for example).
  -->
  <binding id="tabeditor-alltabs-popup"
           extends="chrome://global/content/bindings/popup.xml#popup">
    <implementation implements="nsIDOMEventListener">
      <field name="_xulWindow">
        null
      </field>

      <constructor><![CDATA[
        // We cannot cache the XULBrowserWindow object itself since it might
        // be set after this binding is constructed.
        try {
          this._xulWindow = 
            window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                  .getInterface(Components.interfaces.nsIWebNavigation)
                  .QueryInterface(Components.interfaces.nsIDocShellTreeItem)
                  .treeOwner
                  .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                  .getInterface(Components.interfaces.nsIXULWindow);
        }
        catch(ex) { }
      ]]></constructor>

      <method name="_menuItemOnCommand">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var tabcontainer = document.getBindingParent(this);
          tabcontainer.selectedItem = aEvent.target.tab;
        ]]></body>
      </method>

      <method name="_tabOnAttrModified">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var menuItem = aEvent.target.mCorrespondingMenuitem;
          if (menuItem) {
            var attrName = aEvent.attrName;
            switch (attrName) {
              case "label":
              case "crop":
              case "busy":
              case "image":
              case "selected":
                if (aEvent.attrChange == aEvent.REMOVAL)
                  menuItem.removeAttribute(attrName);
                else
                  menuItem.setAttribute(attrName, aEvent.newValue);
            }
          }
        ]]></body>
      </method>

      <method name="_tabOnTabClose">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var menuItem = aEvent.target.mCorrespondingMenuitem;
          if (menuItem)
            this.removeChild(menuItem);
        ]]></body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (!aEvent.isTrusted)
            return;

          switch (aEvent.type) {
            case "command":
              this._menuItemOnCommand(aEvent);
              break;
            case "DOMAttrModified":
              this._tabOnAttrModified(aEvent);
              break;
            case "TabClose":
              this._tabOnTabClose(aEvent);
              break;
            case "TabOpen":
              this._createTabMenuItem(aEvent.originalTarget);
              break;
            case "scroll":
              this._updateTabsVisibilityStatus();
              break;
          }
        ]]></body>
      </method>

      <method name="_updateTabsVisibilityStatus">
        <body><![CDATA[
          var tabContainer = document.getBindingParent(this);
          // We don't want menu item decoration unless there is overflow.
          if (tabContainer.getAttribute("overflow") != "true")
            return;

          var tabstripBO = tabContainer.mTabstrip.scrollBoxObject;
          for (var i = 0; i < this.childNodes.length; i++) {
            var curTabBO = this.childNodes[i].tab.boxObject;
            if (curTabBO.screenX >= tabstripBO.screenX &&
                curTabBO.screenX + curTabBO.width <= tabstripBO.screenX + tabstripBO.width)
              this.childNodes[i].setAttribute("tabIsVisible", "true"); 
            else
              this.childNodes[i].removeAttribute("tabIsVisible");
          }
        ]]></body>
      </method>

      <method name="_createTabMenuItem">
        <parameter name="aTab"/>
        <body><![CDATA[
          var menuItem = document.createElementNS(
            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", 
            "menuitem");

          menuItem.setAttribute("class", "menuitem-iconic alltabs-item");

          menuItem.setAttribute("label", aTab.label);
          menuItem.setAttribute("crop", aTab.getAttribute("crop"));
          menuItem.setAttribute("image", aTab.getAttribute("image"));

          if (aTab.hasAttribute("busy"))
            menuItem.setAttribute("busy", aTab.getAttribute("busy"));
          if (aTab.selected)
            menuItem.setAttribute("selected", "true");

          // Keep some attributes of the menuitem in sync with its
          // corresponding tab (e.g. the tab label)
          aTab.mCorrespondingMenuitem = menuItem;
          aTab.addEventListener("DOMAttrModified", this, false);
          aTab.addEventListener("TabClose", this, false);
          menuItem.tab = aTab;
          menuItem.addEventListener("command", this, false);

          this.appendChild(menuItem);
          return menuItem;
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="popupshowing">
      <![CDATA[
        // set up the menu popup
        var tabcontainer = document.getBindingParent(this);
        var tabs = tabcontainer.childNodes;

        // Listen for changes in the tab bar.
        var tabbrowser = document.getBindingParent(tabcontainer);
        tabbrowser.addEventListener("TabOpen", this, false);
        tabcontainer.mTabstrip.addEventListener("scroll", this, false);

        // if an animation is in progress and the user
        // clicks on the "all tabs" button, stop the animation
        tabcontainer._stopAnimation();

        for (var i = 0; i < tabs.length; i++) {
          this._createTabMenuItem(tabs[i]);
        }
        this._updateTabsVisibilityStatus();
      ]]></handler>

      <handler event="popuphiding">
      <![CDATA[
        // clear out the menu popup and remove the listeners
        while (this.hasChildNodes()) {
          var menuItem = this.lastChild;
          menuItem.removeEventListener("command", this, false);
          menuItem.tab.removeEventListener("DOMAttrModified", this, false);
          menuItem.tab.removeEventListener("TabClose", this, false);
          menuItem.tab.mCorrespondingMenuitem = null;
          this.removeChild(menuItem);
        }
        var tabcontainer = document.getBindingParent(this);
        tabcontainer.mTabstrip.removeEventListener("scroll", this, false);
        document.getBindingParent(tabcontainer).removeEventListener("TabOpen", this, false);
      ]]></handler>

      <handler event="DOMMenuItemActive">
      <![CDATA[
        if (!this._xulWindow || !this._xulWindow.XULBrowserWindow)
          return;

        var tab = event.target.tab;
        if (tab) {
          var statusText = tab.linkedBrowser.currentURI.spec;
          if (statusText == "about:blank") {
            // XXXhack: Passing a space here (and not "")
            // to make sure the the browser implementation would
            // still consider it a hovered link.
            statusText = " ";
          }

          this._xulWindow.XULBrowserWindow.setOverLink(statusText, null);
        }
      ]]></handler>

      <handler event="DOMMenuItemInactive">
      <![CDATA[
        if (!this._xulWindow || !this._xulWindow.XULBrowserWindow)
          return;

        this._xulWindow.XULBrowserWindow.setOverLink("", null);
      ]]></handler>
    </handlers>
  </binding>

  <!-- close-tab-button binding
       This binding relies on the structure of the tabbrowser binding.
       Therefore it should only be used as a child of the tab or the tabs
       element (in both cases, when they are anonymous nodes of <tabbrowser>).
       This binding is exposed as a pseudo-public-API so themes can customize
       the tabbar appearance without having to be scriptable
       (see globalBindings.xml in Pinstripe for example).
  -->
  <binding id="tabeditor-close-tab-button"
           extends="chrome://global/content/bindings/toolbarbutton.xml#toolbarbutton-image">
    <handlers>
      <handler event="click" button="0"><![CDATA[
        var bindingParent = document.getBindingParent(this);
        if (bindingParent) {
          var tabbedBrowser = document.getBindingParent(bindingParent);
          if (bindingParent.localName == "tab") {
            /* The only sequence in which a second click event (i.e. dblclik)
             * can be dispatched on an in-tab close button is when it is shown
             * after the first click (i.e. the first click event was dispatched
             * on the tab). This happens when we show the close button only on
             * the active tab. (bug 352021)
             * The only sequence in which a third click event can be dispatched
             * on an in-tab close button is when the tab was opened with a
             * double click on the tabbar. (bug 378344)
             * In both cases, it is most likely that the close button area has
             * been accidentally clicked, therefore we do not close the tab.
             *
             * We don't want to ignore processing of more than one click event,
             * though, since the user might actually be repeatedly clicking to
             * close many tabs at once.
             */
            if (event.detail > 1 && !this._ignoredClick) {
              this._ignoredClick = true;
              return;
            }

            // Reset the "ignored click" flag
            this._ignoredClick = false;

            tabbedBrowser.removeTab(bindingParent);
            tabbedBrowser._blockDblClick = true;

            /* XXXmano hack (see bug 343628):
             * Since we're removing the event target, if the user
             * double-clicks this button, the dblclick event will be dispatched
             * with the tabbar as its event target (and explicit/originalTarget),
             * which treats that as a mouse gesture for opening a new tab.
             * In this context, we're manually blocking the dblclick event
             * (see onTabBarDblClick).
             */
            var clickedOnce = false;
            function enableDblClick(event) {
              if (event.detail == 1 && !clickedOnce) {
                clickedOnce = true;
                return;
              }
              setTimeout(function() {
                tabbedBrowser._blockDblClick = false;
              }, 0);
              tabbedBrowser.removeEventListener("click", enableDblClick, false);
            }
            tabbedBrowser.addEventListener("click", enableDblClick, false);
          }
          else // "tabs"
            tabbedBrowser.removeCurrentTab();
        }
      ]]></handler>
      <handler event="dblclick" button="0" phase="capturing">
        // for the one-close-button case
        event.stopPropagation();
      </handler>
    </handlers>
  </binding>

  <binding id="tabeditor-tab" display="xul:hbox"
           extends="chrome://global/content/bindings/tabbox.xml#tab">
    <content chromedir="&locale.dir;"
             closetabtext="&closeTab.label;">
      <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
      <xul:hbox flex="1" class="tab-image-middle" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
          <xul:image class="tab-extra-status"/>
        </xul:stack>
        <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" crop="right" class="tab-text"/>
      </xul:hbox>
      <xul:toolbarbutton anonid="close-button" tabindex="-1" class="tab-close-button"/>
      <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
    </content>

    <implementation>
      <field name="mOverCloseButton">false</field>
      <field name="mCorrespondingMenuitem">null</field>
    </implementation>

    <handlers>
      <handler event="mouseover">
        var anonid = event.originalTarget.getAttribute("anonid");
        if (anonid == "close-button")
          this.mOverCloseButton = true;
      </handler>
      <handler event="mouseout">
        var anonid = event.originalTarget.getAttribute("anonid");
        if (anonid == "close-button")
          this.mOverCloseButton = false;
      </handler>
      <handler event="mousedown" button="0" phase="capturing">
      <![CDATA[
        if (this.mOverCloseButton)
          event.stopPropagation();
      ]]>
      </handler>
    </handlers>
  </binding>

</bindings>
